/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.4.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { authToken, tenantId } from "../../../src/shared/api/config";
import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios";

import * as moment from "moment";

export class AuthorizedApiBase {
  private readonly config: IConfig;

  protected constructor(config: IConfig) {
    this.config = config;
  }

  protected transformOptions = (options: RequestInit): Promise<RequestInit> => {
    options.headers = {
      ...options.headers,
      Authorization: this.config.getAuthorization(),
      TenantId: this.config.getTenantId(),
    };
    return Promise.resolve(options);
  };
  protected getBaseUrl(defaultUrl: string) {
    return this.config.baseUrl();
  }
  protected transformResult(
    url: string,
    response: Response,
    processor: (response: Response) => any
  ) {
    // TODO: Return own result or throw exception to change default processing behavior,
    // or call processor function to run the default processing logic
    let _headers: any = {};
    const status = response.status;
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }

    console.log("Service call: " + url);
    //return processor(response);
    let message = "";
    if (response.status == 200) {
      return processor(response);
    } else {
      switch (response.status) {
        case 400:
          message = "bad request";
          break;
        case 401:
          message = "unauthorized";
          break;
        case 403:
          message = "forbidden";
          break;
        case 404:
          message = "not found";
          break;
        case 500:
          message = "server error";
          break;
        default:
          break;
      }
      return throwException(message, status, null, null);
    }
  }
}

export class AddOnClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  getAddOn(
    id?: string | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<PagedResponseOfGetAddOnResponse>> {
    let url_ = this.baseUrl + "/api/v1/addon?";
    if (id !== undefined && id !== null)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetAddOn(_response)
        );
      });
  }

  protected processGetAddOn(
    response: AxiosResponse
  ): Promise<SwaggerResponse<PagedResponseOfGetAddOnResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetAddOnResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<PagedResponseOfGetAddOnResponse>>(
        new SwaggerResponse<PagedResponseOfGetAddOnResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<PagedResponseOfGetAddOnResponse>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  createAddOn(
    createAddOnRequest: CreateAddOnRequest,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfCreateAddOnResponse>> {
    let url_ = this.baseUrl + "/api/v1/addon";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(createAddOnRequest);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCreateAddOn(_response)
        );
      });
  }

  protected processCreateAddOn(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfCreateAddOnResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfCreateAddOnResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<ResponseOfCreateAddOnResponse>>(
        new SwaggerResponse<ResponseOfCreateAddOnResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<ResponseOfCreateAddOnResponse>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  updateAddOn(
    updateAddOnRequest: UpdateAddOnRequest,
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfGetAddOnResponse>> {
    let url_ = this.baseUrl + "/api/v1/addon/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(updateAddOnRequest);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUpdateAddOn(_response)
        );
      });
  }

  protected processUpdateAddOn(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfGetAddOnResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfGetAddOnResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<ResponseOfGetAddOnResponse>>(
        new SwaggerResponse<ResponseOfGetAddOnResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<ResponseOfGetAddOnResponse>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }
}

export class CategoryClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  getCategory(
    name?: string | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<PagedResponseOfGetCategoryContractResponse>> {
    let url_ = this.baseUrl + "/api/v1/category?";
    if (name !== undefined && name !== null)
      url_ += "Name=" + encodeURIComponent("" + name) + "&";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetCategory(_response)
        );
      });
  }

  protected processGetCategory(
    response: AxiosResponse
  ): Promise<SwaggerResponse<PagedResponseOfGetCategoryContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetCategoryContractResponse.fromJS(
        resultData200
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfGetCategoryContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfGetCategoryContractResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfGetCategoryContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  createCategory(
    id?: string | null | undefined,
    name?: string | null | undefined,
    shortDescription?: string | null | undefined,
    longDescription?: string | null | undefined,
    imagePath?: string | null | undefined,
    restaurantId?: string | null | undefined,
    isEnable?: boolean | null | undefined,
    displayOrder?: number | null | undefined,
    deleteAt?: moment.Moment | null | undefined,
    availableFrom?: moment.Moment | null | undefined,
    availableTo?: moment.Moment | null | undefined,
    image_CanRead?: boolean | undefined,
    image_CanSeek?: boolean | undefined,
    image_CanWrite?: boolean | undefined,
    image_Capacity?: number | undefined,
    image_Length?: number | undefined,
    image_Position?: number | undefined,
    image_CanTimeout?: boolean | undefined,
    image_ReadTimeout?: number | undefined,
    image_WriteTimeout?: number | undefined,
    portionIds?: number[] | null | undefined,
    categoryAvailabilityModels?: CategoryAvailabilityModel[] | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<PagedResponseOfGetCategoryContractResponse>> {
    let url_ = this.baseUrl + "/api/v1/category?";
    if (id !== undefined && id !== null)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    if (name !== undefined && name !== null)
      url_ += "Name=" + encodeURIComponent("" + name) + "&";
    if (shortDescription !== undefined && shortDescription !== null)
      url_ +=
        "ShortDescription=" + encodeURIComponent("" + shortDescription) + "&";
    if (longDescription !== undefined && longDescription !== null)
      url_ +=
        "LongDescription=" + encodeURIComponent("" + longDescription) + "&";
    if (imagePath !== undefined && imagePath !== null)
      url_ += "ImagePath=" + encodeURIComponent("" + imagePath) + "&";
    if (restaurantId !== undefined && restaurantId !== null)
      url_ += "RestaurantId=" + encodeURIComponent("" + restaurantId) + "&";
    if (isEnable !== undefined && isEnable !== null)
      url_ += "IsEnable=" + encodeURIComponent("" + isEnable) + "&";
    if (displayOrder !== undefined && displayOrder !== null)
      url_ += "DisplayOrder=" + encodeURIComponent("" + displayOrder) + "&";
    if (deleteAt !== undefined && deleteAt !== null)
      url_ +=
        "DeleteAt=" +
        encodeURIComponent(deleteAt ? "" + deleteAt.toJSON() : "") +
        "&";
    if (availableFrom !== undefined && availableFrom !== null)
      url_ +=
        "AvailableFrom=" +
        encodeURIComponent(availableFrom ? "" + availableFrom.toJSON() : "") +
        "&";
    if (availableTo !== undefined && availableTo !== null)
      url_ +=
        "AvailableTo=" +
        encodeURIComponent(availableTo ? "" + availableTo.toJSON() : "") +
        "&";
    if (image_CanRead === null)
      throw new Error("The parameter 'image_CanRead' cannot be null.");
    else if (image_CanRead !== undefined)
      url_ += "Image.CanRead=" + encodeURIComponent("" + image_CanRead) + "&";
    if (image_CanSeek === null)
      throw new Error("The parameter 'image_CanSeek' cannot be null.");
    else if (image_CanSeek !== undefined)
      url_ += "Image.CanSeek=" + encodeURIComponent("" + image_CanSeek) + "&";
    if (image_CanWrite === null)
      throw new Error("The parameter 'image_CanWrite' cannot be null.");
    else if (image_CanWrite !== undefined)
      url_ += "Image.CanWrite=" + encodeURIComponent("" + image_CanWrite) + "&";
    if (image_Capacity === null)
      throw new Error("The parameter 'image_Capacity' cannot be null.");
    else if (image_Capacity !== undefined)
      url_ += "Image.Capacity=" + encodeURIComponent("" + image_Capacity) + "&";
    if (image_Length === null)
      throw new Error("The parameter 'image_Length' cannot be null.");
    else if (image_Length !== undefined)
      url_ += "Image.Length=" + encodeURIComponent("" + image_Length) + "&";
    if (image_Position === null)
      throw new Error("The parameter 'image_Position' cannot be null.");
    else if (image_Position !== undefined)
      url_ += "Image.Position=" + encodeURIComponent("" + image_Position) + "&";
    if (image_CanTimeout === null)
      throw new Error("The parameter 'image_CanTimeout' cannot be null.");
    else if (image_CanTimeout !== undefined)
      url_ +=
        "Image.CanTimeout=" + encodeURIComponent("" + image_CanTimeout) + "&";
    if (image_ReadTimeout === null)
      throw new Error("The parameter 'image_ReadTimeout' cannot be null.");
    else if (image_ReadTimeout !== undefined)
      url_ +=
        "Image.ReadTimeout=" + encodeURIComponent("" + image_ReadTimeout) + "&";
    if (image_WriteTimeout === null)
      throw new Error("The parameter 'image_WriteTimeout' cannot be null.");
    else if (image_WriteTimeout !== undefined)
      url_ +=
        "Image.WriteTimeout=" +
        encodeURIComponent("" + image_WriteTimeout) +
        "&";
    if (portionIds !== undefined && portionIds !== null)
      portionIds &&
        portionIds.forEach((item) => {
          url_ += "PortionIds=" + encodeURIComponent("" + item) + "&";
        });
    if (
      categoryAvailabilityModels !== undefined &&
      categoryAvailabilityModels !== null
    )
      categoryAvailabilityModels &&
        categoryAvailabilityModels.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                "CategoryAvailabilityModels[" +
                index +
                "]." +
                attr +
                "=" +
                encodeURIComponent("" + (<any>item)[attr]) +
                "&";
            }
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCreateCategory(_response)
        );
      });
  }

  protected processCreateCategory(
    response: AxiosResponse
  ): Promise<SwaggerResponse<PagedResponseOfGetCategoryContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetCategoryContractResponse.fromJS(
        resultData200
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfGetCategoryContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfGetCategoryContractResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfGetCategoryContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  updateCategory(
    id?: string | null | undefined,
    name?: string | null | undefined,
    shortDescription?: string | null | undefined,
    longDescription?: string | null | undefined,
    imagePath?: string | null | undefined,
    restaurantId?: string | null | undefined,
    isEnable?: boolean | null | undefined,
    displayOrder?: number | null | undefined,
    deleteAt?: moment.Moment | null | undefined,
    availableFrom?: moment.Moment | null | undefined,
    availableTo?: moment.Moment | null | undefined,
    image_CanRead?: boolean | undefined,
    image_CanSeek?: boolean | undefined,
    image_CanWrite?: boolean | undefined,
    image_Capacity?: number | undefined,
    image_Length?: number | undefined,
    image_Position?: number | undefined,
    image_CanTimeout?: boolean | undefined,
    image_ReadTimeout?: number | undefined,
    image_WriteTimeout?: number | undefined,
    portionIds?: number[] | null | undefined,
    categoryAvailabilityModels?: CategoryAvailabilityModel[] | null | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<PagedResponseOfGetCategoryContractResponse>> {
    let url_ = this.baseUrl + "/api/v1/category/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (id !== undefined && id !== null)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    if (name !== undefined && name !== null)
      url_ += "Name=" + encodeURIComponent("" + name) + "&";
    if (shortDescription !== undefined && shortDescription !== null)
      url_ +=
        "ShortDescription=" + encodeURIComponent("" + shortDescription) + "&";
    if (longDescription !== undefined && longDescription !== null)
      url_ +=
        "LongDescription=" + encodeURIComponent("" + longDescription) + "&";
    if (imagePath !== undefined && imagePath !== null)
      url_ += "ImagePath=" + encodeURIComponent("" + imagePath) + "&";
    if (restaurantId !== undefined && restaurantId !== null)
      url_ += "RestaurantId=" + encodeURIComponent("" + restaurantId) + "&";
    if (isEnable !== undefined && isEnable !== null)
      url_ += "isEnable=" + encodeURIComponent("" + isEnable) + "&";
    if (displayOrder !== undefined && displayOrder !== null)
      url_ += "DisplayOrder=" + encodeURIComponent("" + displayOrder) + "&";
    if (deleteAt !== undefined && deleteAt !== null)
      url_ +=
        "DeleteAt=" +
        encodeURIComponent(deleteAt ? "" + deleteAt.toJSON() : "") +
        "&";
    if (availableFrom !== undefined && availableFrom !== null)
      url_ +=
        "AvailableFrom=" +
        encodeURIComponent(availableFrom ? "" + availableFrom.toJSON() : "") +
        "&";
    if (availableTo !== undefined && availableTo !== null)
      url_ +=
        "AvailableTo=" +
        encodeURIComponent(availableTo ? "" + availableTo.toJSON() : "") +
        "&";
    if (image_CanRead === null)
      throw new Error("The parameter 'image_CanRead' cannot be null.");
    else if (image_CanRead !== undefined)
      url_ += "Image.CanRead=" + encodeURIComponent("" + image_CanRead) + "&";
    if (image_CanSeek === null)
      throw new Error("The parameter 'image_CanSeek' cannot be null.");
    else if (image_CanSeek !== undefined)
      url_ += "Image.CanSeek=" + encodeURIComponent("" + image_CanSeek) + "&";
    if (image_CanWrite === null)
      throw new Error("The parameter 'image_CanWrite' cannot be null.");
    else if (image_CanWrite !== undefined)
      url_ += "Image.CanWrite=" + encodeURIComponent("" + image_CanWrite) + "&";
    if (image_Capacity === null)
      throw new Error("The parameter 'image_Capacity' cannot be null.");
    else if (image_Capacity !== undefined)
      url_ += "Image.Capacity=" + encodeURIComponent("" + image_Capacity) + "&";
    if (image_Length === null)
      throw new Error("The parameter 'image_Length' cannot be null.");
    else if (image_Length !== undefined)
      url_ += "Image.Length=" + encodeURIComponent("" + image_Length) + "&";
    if (image_Position === null)
      throw new Error("The parameter 'image_Position' cannot be null.");
    else if (image_Position !== undefined)
      url_ += "Image.Position=" + encodeURIComponent("" + image_Position) + "&";
    if (image_CanTimeout === null)
      throw new Error("The parameter 'image_CanTimeout' cannot be null.");
    else if (image_CanTimeout !== undefined)
      url_ +=
        "Image.CanTimeout=" + encodeURIComponent("" + image_CanTimeout) + "&";
    if (image_ReadTimeout === null)
      throw new Error("The parameter 'image_ReadTimeout' cannot be null.");
    else if (image_ReadTimeout !== undefined)
      url_ +=
        "Image.ReadTimeout=" + encodeURIComponent("" + image_ReadTimeout) + "&";
    if (image_WriteTimeout === null)
      throw new Error("The parameter 'image_WriteTimeout' cannot be null.");
    else if (image_WriteTimeout !== undefined)
      url_ +=
        "Image.WriteTimeout=" +
        encodeURIComponent("" + image_WriteTimeout) +
        "&";
    if (portionIds !== undefined && portionIds !== null)
      portionIds &&
        portionIds.forEach((item) => {
          url_ += "PortionIds=" + encodeURIComponent("" + item) + "&";
        });
    if (
      categoryAvailabilityModels !== undefined &&
      categoryAvailabilityModels !== null
    )
      categoryAvailabilityModels &&
        categoryAvailabilityModels.forEach((item, index) => {
          for (let attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                "categoryAvailabilityModels[" +
                index +
                "]." +
                attr +
                "=" +
                encodeURIComponent("" + (<any>item)[attr]) +
                "&";
            }
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "PUT",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUpdateCategory(_response)
        );
      });
  }

  protected processUpdateCategory(
    response: AxiosResponse
  ): Promise<SwaggerResponse<PagedResponseOfGetCategoryContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PagedResponseOfGetCategoryContractResponse.fromJS(
        resultData200
      );
      return Promise.resolve<
        SwaggerResponse<PagedResponseOfGetCategoryContractResponse>
      >(
        new SwaggerResponse<PagedResponseOfGetCategoryContractResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<PagedResponseOfGetCategoryContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class CustomerClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  getCustomers(
    id?: string | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfGetCustomerResponse>> {
    let url_ = this.baseUrl + "/api/v1/customer?";
    if (id !== undefined && id !== null)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetCustomers(_response)
        );
      });
  }

  protected processGetCustomers(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfGetCustomerResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfGetCustomerResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<ResponseOfGetCustomerResponse>>(
        new SwaggerResponse<ResponseOfGetCustomerResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<ResponseOfGetCustomerResponse>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }
}

export class DriverClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  getDrivers(
    id?: number | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfGetDriverContractResponse>> {
    let url_ = this.baseUrl + "/api/v1/drivers?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetDrivers(_response)
        );
      });
  }

  protected processGetDrivers(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfGetDriverContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfGetDriverContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfGetDriverContractResponse>
      >(
        new SwaggerResponse<ResponseOfGetDriverContractResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfGetDriverContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  createDriver(
    createDriverContractRequest?:
      | CreateDriverContractRequest
      | null
      | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfCreateDriverContractRequest>> {
    let url_ = this.baseUrl + "/api/v1/drivers?";
    if (
      createDriverContractRequest !== undefined &&
      createDriverContractRequest !== null
    )
      url_ +=
        "createDriverContractRequest=" +
        encodeURIComponent("" + createDriverContractRequest) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "POST",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCreateDriver(_response)
        );
      });
  }

  protected processCreateDriver(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfCreateDriverContractRequest>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfCreateDriverContractRequest.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfCreateDriverContractRequest>
      >(
        new SwaggerResponse<ResponseOfCreateDriverContractRequest>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfCreateDriverContractRequest>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  updateDriver(
    id: string,
    updateDriverContractRequest?:
      | UpdateDriverContractRequest
      | null
      | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfUpdateDriverContractResponse>> {
    let url_ = this.baseUrl + "/api/v1/drivers/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (
      updateDriverContractRequest !== undefined &&
      updateDriverContractRequest !== null
    )
      url_ +=
        "updateDriverContractRequest=" +
        encodeURIComponent("" + updateDriverContractRequest) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "PUT",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUpdateDriver(_response)
        );
      });
  }

  protected processUpdateDriver(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfUpdateDriverContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfUpdateDriverContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfUpdateDriverContractResponse>
      >(
        new SwaggerResponse<ResponseOfUpdateDriverContractResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfUpdateDriverContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class FileClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  viewImage(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/viewImage/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processViewImage(_response)
        );
      });
  }

  protected processViewImage(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  admin(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/Admin/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processAdmin(_response)
        );
      });
  }

  protected processAdmin(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  category(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/Category/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCategory(_response)
        );
      });
  }

  protected processCategory(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  product(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/Product/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processProduct(_response)
        );
      });
  }

  protected processProduct(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  gallery(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/Gallery/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGallery(_response)
        );
      });
  }

  protected processGallery(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  default(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/Default/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processDefault(_response)
        );
      });
  }

  protected processDefault(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  users(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/Users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUsers(_response)
        );
      });
  }

  protected processUsers(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  driver(
    id: string | null,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<FileResponse | null>> {
    let url_ = this.baseUrl + "/api/v1/File/Driver/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      responseType: "blob",
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/octet-stream",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processDriver(_response)
        );
      });
  }

  protected processDriver(
    response: AxiosResponse
  ): Promise<SwaggerResponse<FileResponse | null>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers["content-disposition"]
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return Promise.resolve<SwaggerResponse<FileResponse | null>>(
        new SwaggerResponse(status, _headers, {
          fileName: fileName,
          status: status,
          data: new Blob([response.data]),
          headers: _headers,
        })
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<FileResponse | null>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }
}

export class OrdersClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  getOrders(
    driverId?: string | null | undefined,
    orderTypeId?: string | null | undefined,
    isDriver?: boolean | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfListOfGetOrderContractResponse>> {
    let url_ = this.baseUrl + "/api/v1/order?";
    if (driverId !== undefined && driverId !== null)
      url_ += "DriverId=" + encodeURIComponent("" + driverId) + "&";
    if (orderTypeId !== undefined && orderTypeId !== null)
      url_ += "OrderTypeId=" + encodeURIComponent("" + orderTypeId) + "&";
    if (isDriver === null)
      throw new Error("The parameter 'isDriver' cannot be null.");
    else if (isDriver !== undefined)
      url_ += "IsDriver=" + encodeURIComponent("" + isDriver) + "&";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetOrders(_response)
        );
      });
  }

  protected processGetOrders(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfListOfGetOrderContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfListOfGetOrderContractResponse.fromJS(
        resultData200
      );
      return Promise.resolve<
        SwaggerResponse<ResponseOfListOfGetOrderContractResponse>
      >(
        new SwaggerResponse<ResponseOfListOfGetOrderContractResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfListOfGetOrderContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }

  updateOrderStatus(
    id: string,
    orderId?: string | null | undefined,
    reason?: string | null | undefined,
    driverId?: string | null | undefined,
    orderStatus?: OrderStatus | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<ResponseOfUpdateOrderContractResponse>> {
    let url_ = this.baseUrl + "/api/v1/order/{id}?";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (orderId !== undefined && orderId !== null)
      url_ += "OrderId=" + encodeURIComponent("" + orderId) + "&";
    if (reason !== undefined && reason !== null)
      url_ += "Reason=" + encodeURIComponent("" + reason) + "&";
    if (driverId !== undefined && driverId !== null)
      url_ += "DriverId=" + encodeURIComponent("" + driverId) + "&";
    if (orderStatus === null)
      throw new Error("The parameter 'orderStatus' cannot be null.");
    else if (orderStatus !== undefined)
      url_ += "OrderStatus=" + encodeURIComponent("" + orderStatus) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "PUT",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUpdateOrderStatus(_response)
        );
      });
  }

  protected processUpdateOrderStatus(
    response: AxiosResponse
  ): Promise<SwaggerResponse<ResponseOfUpdateOrderContractResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ResponseOfUpdateOrderContractResponse.fromJS(resultData200);
      return Promise.resolve<
        SwaggerResponse<ResponseOfUpdateOrderContractResponse>
      >(
        new SwaggerResponse<ResponseOfUpdateOrderContractResponse>(
          status,
          _headers,
          result200
        )
      );
    } else if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<
      SwaggerResponse<ResponseOfUpdateOrderContractResponse>
    >(new SwaggerResponse(status, _headers, <any>null));
  }
}

export class PortionClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  getPortion(
    id?: string | null | undefined,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<void>> {
    let url_ = this.baseUrl + "/api/v1/portion?";
    if (id !== undefined && id !== null)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetPortion(_response)
        );
      });
  }

  protected processGetPortion(
    response: AxiosResponse
  ): Promise<SwaggerResponse<void>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<void>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  createPortion(
    createPortionRequest: CreatePortionRequest,
    pageNumber?: number | undefined,
    pageSize?: number | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<void>> {
    let url_ = this.baseUrl + "/api/v1/portion?";
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
      throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
      url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(createPortionRequest);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processCreatePortion(_response)
        );
      });
  }

  protected processCreatePortion(
    response: AxiosResponse
  ): Promise<SwaggerResponse<void>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<void>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  updatePortion(
    updatePortionSizeRequest: UpdatePortionSizeRequest,
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<void>> {
    let url_ = this.baseUrl + "/api/v1/portion/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(updatePortionSizeRequest);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processUpdatePortion(_response)
        );
      });
  }

  protected processUpdatePortion(
    response: AxiosResponse
  ): Promise<SwaggerResponse<void>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<void>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  deletePortion(
    deletePortionRequest: DeletePortionRequest,
    id: string,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<void>> {
    let url_ = this.baseUrl + "/api/v1/portion/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(deletePortionRequest);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "DELETE",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processDeletePortion(_response)
        );
      });
  }

  protected processDeletePortion(
    response: AxiosResponse
  ): Promise<SwaggerResponse<void>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<void>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }
}

export class RestaurantClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  getPortion(
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<void>> {
    let url_ = this.baseUrl + "/api/v1/restaurant";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processGetPortion(_response)
        );
      });
  }

  protected processGetPortion(
    response: AxiosResponse
  ): Promise<SwaggerResponse<void>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 412) {
      const _responseText = response.data;
      let result412: any = null;
      let resultData412 = _responseText;
      result412 = BadResponse.fromJS(resultData412);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result412
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = ErrorResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<void>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }
}

export class IdentityClient extends AuthorizedApiBase {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    configuration: IConfig,
    baseUrl?: string,
    instance?: AxiosInstance
  ) {
    super(configuration);
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://empite.host");
  }

  register(
    request: UserRegistrationRequest,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    let url_ = this.baseUrl + "/api/v1/identity/register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processRegister(_response)
        );
      });
  }

  protected processRegister(
    response: AxiosResponse
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = AuthSuccessResponse.fromJS(resultData201);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result201)
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = AuthFailedResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status === 500) {
      const _responseText = response.data;
      let result500: any = null;
      let resultData500 = _responseText;
      result500 = AuthFailedResponse.fromJS(resultData500);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result500
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  login(
    request: UserLoginRequest,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    let url_ = this.baseUrl + "/api/v1/identity/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processLogin(_response)
        );
      });
  }

  protected processLogin(
    response: AxiosResponse
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = AuthSuccessResponse.fromJS(resultData201);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result201)
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AuthSuccessResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result200)
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = AuthFailedResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }

  refresh(
    request: RefreshTokenRequest,
    cancelToken?: CancelToken | undefined
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    let url_ = this.baseUrl + "/api/v1/identity/refresh";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.transformOptions(options_)
      .then((transformedOptions_) => {
        return this.instance.request(transformedOptions_);
      })
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.transformResult(
          url_,
          _response,
          (_response: AxiosResponse) => this.processRefresh(_response)
        );
      });
  }

  protected processRefresh(
    response: AxiosResponse
  ): Promise<SwaggerResponse<AuthSuccessResponse>> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = AuthSuccessResponse.fromJS(resultData201);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result201)
      );
    } else if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = AuthSuccessResponse.fromJS(resultData200);
      return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
        new SwaggerResponse<AuthSuccessResponse>(status, _headers, result200)
      );
    } else if (status === 400) {
      const _responseText = response.data;
      let result400: any = null;
      let resultData400 = _responseText;
      result400 = AuthFailedResponse.fromJS(resultData400);
      return throwException(
        "A server side error occurred.",
        status,
        _responseText,
        _headers,
        result400
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SwaggerResponse<AuthSuccessResponse>>(
      new SwaggerResponse(status, _headers, <any>null)
    );
  }
}

export class PagedResponseOfGetAddOnResponse
  implements IPagedResponseOfGetAddOnResponse {
  data?: GetAddOnResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfGetAddOnResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(GetAddOnResponse.fromJS(item));
      }
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this._links = _data["_links"]
        ? Links.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfGetAddOnResponse {
    data = typeof data === "object" ? data : {};
    let result = new PagedResponseOfGetAddOnResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data) data["data"].push(item.toJSON());
    }
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfGetAddOnResponse {
  data?: GetAddOnResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetAddOnResponse implements IGetAddOnResponse {
  addOnListModels?: AddOnListModel[] | undefined;

  constructor(data?: IGetAddOnResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["addOnListModels"])) {
        this.addOnListModels = [] as any;
        for (let item of _data["addOnListModels"])
          this.addOnListModels!.push(AddOnListModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetAddOnResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetAddOnResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.addOnListModels)) {
      data["addOnListModels"] = [];
      for (let item of this.addOnListModels)
        data["addOnListModels"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetAddOnResponse {
  addOnListModels?: AddOnListModel[] | undefined;
}

export class AddOnListModel implements IAddOnListModel {
  id?: string | undefined;
  name?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;

  constructor(data?: IAddOnListModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.price = _data["price"];
      this.isEnable = _data["isEnable"];
    }
  }

  static fromJS(data: any): AddOnListModel {
    data = typeof data === "object" ? data : {};
    let result = new AddOnListModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["price"] = this.price;
    data["isEnable"] = this.isEnable;
    return data;
  }
}

export interface IAddOnListModel {
  id?: string | undefined;
  name?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
}

export class LinkBase implements ILinkBase {
  self?: LinkHref | undefined;

  constructor(data?: ILinkBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.self = _data["self"]
        ? LinkHref.fromJS(_data["self"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): LinkBase {
    data = typeof data === "object" ? data : {};
    let result = new LinkBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["self"] = this.self ? this.self.toJSON() : <any>undefined;
    return data;
  }
}

export interface ILinkBase {
  self?: LinkHref | undefined;
}

export class Links extends LinkBase implements ILinks {
  next?: LinkHref | undefined;
  prev?: LinkHref | undefined;
  first?: LinkHref | undefined;
  last?: LinkHref | undefined;

  constructor(data?: ILinks) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.next = _data["next"]
        ? LinkHref.fromJS(_data["next"])
        : <any>undefined;
      this.prev = _data["prev"]
        ? LinkHref.fromJS(_data["prev"])
        : <any>undefined;
      this.first = _data["first"]
        ? LinkHref.fromJS(_data["first"])
        : <any>undefined;
      this.last = _data["last"]
        ? LinkHref.fromJS(_data["last"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): Links {
    data = typeof data === "object" ? data : {};
    let result = new Links();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["next"] = this.next ? this.next.toJSON() : <any>undefined;
    data["prev"] = this.prev ? this.prev.toJSON() : <any>undefined;
    data["first"] = this.first ? this.first.toJSON() : <any>undefined;
    data["last"] = this.last ? this.last.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface ILinks extends ILinkBase {
  next?: LinkHref | undefined;
  prev?: LinkHref | undefined;
  first?: LinkHref | undefined;
  last?: LinkHref | undefined;
}

export class LinkHref implements ILinkHref {
  href?: string | undefined;

  constructor(data?: ILinkHref) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.href = _data["href"];
    }
  }

  static fromJS(data: any): LinkHref {
    data = typeof data === "object" ? data : {};
    let result = new LinkHref();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["href"] = this.href;
    return data;
  }
}

export interface ILinkHref {
  href?: string | undefined;
}

export class BadResponse implements IBadResponse {
  errors?: BadResponseHolder[] | undefined;

  constructor(data?: IBadResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"])
          this.errors!.push(BadResponseHolder.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BadResponse {
    data = typeof data === "object" ? data : {};
    let result = new BadResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IBadResponse {
  errors?: BadResponseHolder[] | undefined;
}

export class BadResponseHolder implements IBadResponseHolder {
  status!: number;
  error?: string | undefined;

  constructor(data?: IBadResponseHolder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.status = _data["status"];
      this.error = _data["error"];
    }
  }

  static fromJS(data: any): BadResponseHolder {
    data = typeof data === "object" ? data : {};
    let result = new BadResponseHolder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["status"] = this.status;
    data["error"] = this.error;
    return data;
  }
}

export interface IBadResponseHolder {
  status: number;
  error?: string | undefined;
}

export class ErrorResponse implements IErrorResponse {
  errors?: ErrorModel[] | undefined;

  constructor(data?: IErrorResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"])
          this.errors!.push(ErrorModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ErrorResponse {
    data = typeof data === "object" ? data : {};
    let result = new ErrorResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item.toJSON());
    }
    return data;
  }
}

export interface IErrorResponse {
  errors?: ErrorModel[] | undefined;
}

export class ErrorModel implements IErrorModel {
  fieldName?: string | undefined;
  message?: string | undefined;

  constructor(data?: IErrorModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fieldName = _data["fieldName"];
      this.message = _data["message"];
    }
  }

  static fromJS(data: any): ErrorModel {
    data = typeof data === "object" ? data : {};
    let result = new ErrorModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["fieldName"] = this.fieldName;
    data["message"] = this.message;
    return data;
  }
}

export interface IErrorModel {
  fieldName?: string | undefined;
  message?: string | undefined;
}

export class ResponseOfCreateAddOnResponse
  implements IResponseOfCreateAddOnResponse {
  data?: CreateAddOnResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfCreateAddOnResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? CreateAddOnResponse.fromJS(_data["data"])
        : <any>undefined;
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfCreateAddOnResponse {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfCreateAddOnResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfCreateAddOnResponse {
  data?: CreateAddOnResponse | undefined;
  _links?: LinkBase | undefined;
}

export class CreateAddOnResponse implements ICreateAddOnResponse {
  addOnListModels?: CreateAddOnListModel[] | undefined;

  constructor(data?: ICreateAddOnResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["addOnListModels"])) {
        this.addOnListModels = [] as any;
        for (let item of _data["addOnListModels"])
          this.addOnListModels!.push(CreateAddOnListModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreateAddOnResponse {
    data = typeof data === "object" ? data : {};
    let result = new CreateAddOnResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.addOnListModels)) {
      data["addOnListModels"] = [];
      for (let item of this.addOnListModels)
        data["addOnListModels"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICreateAddOnResponse {
  addOnListModels?: CreateAddOnListModel[] | undefined;
}

export class CreateAddOnListModel implements ICreateAddOnListModel {
  id?: string | undefined;
  name?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;

  constructor(data?: ICreateAddOnListModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.price = _data["price"];
      this.isEnable = _data["isEnable"];
    }
  }

  static fromJS(data: any): CreateAddOnListModel {
    data = typeof data === "object" ? data : {};
    let result = new CreateAddOnListModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["price"] = this.price;
    data["isEnable"] = this.isEnable;
    return data;
  }
}

export interface ICreateAddOnListModel {
  id?: string | undefined;
  name?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
}

export class CreateAddOnRequest implements ICreateAddOnRequest {
  id?: string | undefined;
  name?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;
  toppingModel?: ToppingModel | undefined;

  constructor(data?: ICreateAddOnRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.price = _data["price"];
      this.isEnable = _data["isEnable"];
      this.toppingModel = _data["toppingModel"]
        ? ToppingModel.fromJS(_data["toppingModel"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CreateAddOnRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateAddOnRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["price"] = this.price;
    data["isEnable"] = this.isEnable;
    data["toppingModel"] = this.toppingModel
      ? this.toppingModel.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface ICreateAddOnRequest {
  id?: string | undefined;
  name?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
  toppingModel?: ToppingModel | undefined;
}

export class BaseModel implements IBaseModel {
  events?: BaseDomainEvent[] | undefined;
  id!: number;

  constructor(data?: IBaseModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["events"])) {
        this.events = [] as any;
        for (let item of _data["events"])
          this.events!.push(BaseDomainEvent.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): BaseModel {
    data = typeof data === "object" ? data : {};
    let result = new BaseModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.events)) {
      data["events"] = [];
      for (let item of this.events) data["events"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface IBaseModel {
  events?: BaseDomainEvent[] | undefined;
  id: number;
}

export class ToppingModel extends BaseModel implements IToppingModel {
  id?: string | undefined;
  name?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;
  deletedAt?: moment.Moment | undefined;
  restaurantId?: string | undefined;
  addonCategories?: AddonCategoryModel[] | undefined;

  constructor(data?: IToppingModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.price = _data["price"];
      this.isEnable = _data["isEnable"];
      this.deletedAt = _data["deletedAt"]
        ? moment(_data["deletedAt"].toString())
        : <any>undefined;
      this.restaurantId = _data["restaurantId"];
      if (Array.isArray(_data["addonCategories"])) {
        this.addonCategories = [] as any;
        for (let item of _data["addonCategories"])
          this.addonCategories!.push(AddonCategoryModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ToppingModel {
    data = typeof data === "object" ? data : {};
    let result = new ToppingModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["price"] = this.price;
    data["isEnable"] = this.isEnable;
    data["deletedAt"] = this.deletedAt
      ? this.deletedAt.toISOString()
      : <any>undefined;
    data["restaurantId"] = this.restaurantId;
    if (Array.isArray(this.addonCategories)) {
      data["addonCategories"] = [];
      for (let item of this.addonCategories)
        data["addonCategories"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IToppingModel extends IBaseModel {
  id?: string | undefined;
  name?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
  deletedAt?: moment.Moment | undefined;
  restaurantId?: string | undefined;
  addonCategories?: AddonCategoryModel[] | undefined;
}

export class AddonCategoryModel
  extends BaseModel
  implements IAddonCategoryModel {
  id?: string | undefined;
  toppingId?: string | undefined;
  topping?: ToppingModel | undefined;
  categoryId?: string | undefined;
  category?: CategoryModel | undefined;

  constructor(data?: IAddonCategoryModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.toppingId = _data["toppingId"];
      this.topping = _data["topping"]
        ? ToppingModel.fromJS(_data["topping"])
        : <any>undefined;
      this.categoryId = _data["categoryId"];
      this.category = _data["category"]
        ? CategoryModel.fromJS(_data["category"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddonCategoryModel {
    data = typeof data === "object" ? data : {};
    let result = new AddonCategoryModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["toppingId"] = this.toppingId;
    data["topping"] = this.topping ? this.topping.toJSON() : <any>undefined;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IAddonCategoryModel extends IBaseModel {
  id?: string | undefined;
  toppingId?: string | undefined;
  topping?: ToppingModel | undefined;
  categoryId?: string | undefined;
  category?: CategoryModel | undefined;
}

export class CategoryModel implements ICategoryModel {
  id?: string | undefined;
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId?: string | undefined;
  isEnable?: boolean | undefined;
  displayOrder?: number | undefined;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  products?: ProductListModel[] | undefined;
  image?: MemoryStream | undefined;
  portionIds?: number[] | undefined;
  categoryAvailabilityModels?: CategoryAvailabilityModel[] | undefined;

  constructor(data?: ICategoryModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.shortDescription = _data["shortDescription"];
      this.longDescription = _data["longDescription"];
      this.imagePath = _data["imagePath"];
      this.restaurantId = _data["restaurantId"];
      this.isEnable = _data["isEnable"];
      this.displayOrder = _data["displayOrder"];
      this.deleteAt = _data["deleteAt"]
        ? moment(_data["deleteAt"].toString())
        : <any>undefined;
      this.availableFrom = _data["availableFrom"]
        ? moment(_data["availableFrom"].toString())
        : <any>undefined;
      this.availableTo = _data["availableTo"]
        ? moment(_data["availableTo"].toString())
        : <any>undefined;
      if (Array.isArray(_data["products"])) {
        this.products = [] as any;
        for (let item of _data["products"])
          this.products!.push(ProductListModel.fromJS(item));
      }
      this.image = _data["image"]
        ? MemoryStream.fromJS(_data["image"])
        : <any>undefined;
      if (Array.isArray(_data["portionIds"])) {
        this.portionIds = [] as any;
        for (let item of _data["portionIds"]) this.portionIds!.push(item);
      }
      if (Array.isArray(_data["categoryAvailabilityModels"])) {
        this.categoryAvailabilityModels = [] as any;
        for (let item of _data["categoryAvailabilityModels"])
          this.categoryAvailabilityModels!.push(
            CategoryAvailabilityModel.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): CategoryModel {
    data = typeof data === "object" ? data : {};
    let result = new CategoryModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["shortDescription"] = this.shortDescription;
    data["longDescription"] = this.longDescription;
    data["imagePath"] = this.imagePath;
    data["restaurantId"] = this.restaurantId;
    data["isEnable"] = this.isEnable;
    data["displayOrder"] = this.displayOrder;
    data["deleteAt"] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data["availableFrom"] = this.availableFrom
      ? this.availableFrom.toISOString()
      : <any>undefined;
    data["availableTo"] = this.availableTo
      ? this.availableTo.toISOString()
      : <any>undefined;
    if (Array.isArray(this.products)) {
      data["products"] = [];
      for (let item of this.products) data["products"].push(item.toJSON());
    }
    data["image"] = this.image ? this.image.toJSON() : <any>undefined;
    if (Array.isArray(this.portionIds)) {
      data["portionIds"] = [];
      for (let item of this.portionIds) data["portionIds"].push(item);
    }
    if (Array.isArray(this.categoryAvailabilityModels)) {
      data["categoryAvailabilityModels"] = [];
      for (let item of this.categoryAvailabilityModels)
        data["categoryAvailabilityModels"].push(item.toJSON());
    }
    return data;
  }
}

export interface ICategoryModel {
  id?: string | undefined;
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId?: string | undefined;
  isEnable?: boolean | undefined;
  displayOrder?: number | undefined;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  products?: ProductListModel[] | undefined;
  image?: MemoryStream | undefined;
  portionIds?: number[] | undefined;
  categoryAvailabilityModels?: CategoryAvailabilityModel[] | undefined;
}

export class ProductListModel implements IProductListModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  summary?: string | undefined;
  ingredient?: string | undefined;
  unitPrice?: number | undefined;
  offerPrice?: number | undefined;
  toppingPrice?: number | undefined;
  rate?: number | undefined;
  categoryId?: string | undefined;
  isEnable!: boolean;
  isParent!: boolean;
  isAddon!: boolean;
  parentId?: string | undefined;
  mainImage?: string | undefined;
  portionSizeId?: string | undefined;
  toppingId!: string;
  deleteAt?: moment.Moment | undefined;
  category?: Category | undefined;
  portionSize?: CategoryPortion | undefined;
  topping?: Topping | undefined;
  categoryPortionModels?: CategoryPortionModel[] | undefined;
  toppings?: Topping[] | undefined;
  isSoldOut!: boolean;
  isDeliverable!: boolean;

  constructor(data?: IProductListModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.summary = _data["summary"];
      this.ingredient = _data["ingredient"];
      this.unitPrice = _data["unitPrice"];
      this.offerPrice = _data["offerPrice"];
      this.toppingPrice = _data["toppingPrice"];
      this.rate = _data["rate"];
      this.categoryId = _data["categoryId"];
      this.isEnable = _data["isEnable"];
      this.isParent = _data["isParent"];
      this.isAddon = _data["isAddon"];
      this.parentId = _data["parentId"];
      this.mainImage = _data["mainImage"];
      this.portionSizeId = _data["portionSizeId"];
      this.toppingId = _data["toppingId"];
      this.deleteAt = _data["deleteAt"]
        ? moment(_data["deleteAt"].toString())
        : <any>undefined;
      this.category = _data["category"]
        ? Category.fromJS(_data["category"])
        : <any>undefined;
      this.portionSize = _data["portionSize"]
        ? CategoryPortion.fromJS(_data["portionSize"])
        : <any>undefined;
      this.topping = _data["topping"]
        ? Topping.fromJS(_data["topping"])
        : <any>undefined;
      if (Array.isArray(_data["categoryPortionModels"])) {
        this.categoryPortionModels = [] as any;
        for (let item of _data["categoryPortionModels"])
          this.categoryPortionModels!.push(CategoryPortionModel.fromJS(item));
      }
      if (Array.isArray(_data["toppings"])) {
        this.toppings = [] as any;
        for (let item of _data["toppings"])
          this.toppings!.push(Topping.fromJS(item));
      }
      this.isSoldOut = _data["isSoldOut"];
      this.isDeliverable = _data["isDeliverable"];
    }
  }

  static fromJS(data: any): ProductListModel {
    data = typeof data === "object" ? data : {};
    let result = new ProductListModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["description"] = this.description;
    data["summary"] = this.summary;
    data["ingredient"] = this.ingredient;
    data["unitPrice"] = this.unitPrice;
    data["offerPrice"] = this.offerPrice;
    data["toppingPrice"] = this.toppingPrice;
    data["rate"] = this.rate;
    data["categoryId"] = this.categoryId;
    data["isEnable"] = this.isEnable;
    data["isParent"] = this.isParent;
    data["isAddon"] = this.isAddon;
    data["parentId"] = this.parentId;
    data["mainImage"] = this.mainImage;
    data["portionSizeId"] = this.portionSizeId;
    data["toppingId"] = this.toppingId;
    data["deleteAt"] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    data["portionSize"] = this.portionSize
      ? this.portionSize.toJSON()
      : <any>undefined;
    data["topping"] = this.topping ? this.topping.toJSON() : <any>undefined;
    if (Array.isArray(this.categoryPortionModels)) {
      data["categoryPortionModels"] = [];
      for (let item of this.categoryPortionModels)
        data["categoryPortionModels"].push(item.toJSON());
    }
    if (Array.isArray(this.toppings)) {
      data["toppings"] = [];
      for (let item of this.toppings) data["toppings"].push(item.toJSON());
    }
    data["isSoldOut"] = this.isSoldOut;
    data["isDeliverable"] = this.isDeliverable;
    return data;
  }
}

export interface IProductListModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  summary?: string | undefined;
  ingredient?: string | undefined;
  unitPrice?: number | undefined;
  offerPrice?: number | undefined;
  toppingPrice?: number | undefined;
  rate?: number | undefined;
  categoryId?: string | undefined;
  isEnable: boolean;
  isParent: boolean;
  isAddon: boolean;
  parentId?: string | undefined;
  mainImage?: string | undefined;
  portionSizeId?: string | undefined;
  toppingId: string;
  deleteAt?: moment.Moment | undefined;
  category?: Category | undefined;
  portionSize?: CategoryPortion | undefined;
  topping?: Topping | undefined;
  categoryPortionModels?: CategoryPortionModel[] | undefined;
  toppings?: Topping[] | undefined;
  isSoldOut: boolean;
  isDeliverable: boolean;
}

export abstract class EntityBaseOfGuid implements IEntityBaseOfGuid {
  events?: BaseDomainEvent[] | undefined;
  id!: string;
  createdBy?: string | undefined;
  lastModifiedBy?: string | undefined;
  createdAt!: moment.Moment;
  lastModifiedAt?: moment.Moment | undefined;

  constructor(data?: IEntityBaseOfGuid) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["events"])) {
        this.events = [] as any;
        for (let item of _data["events"])
          this.events!.push(BaseDomainEvent.fromJS(item));
      }
      this.id = _data["id"];
      this.createdBy = _data["createdBy"];
      this.lastModifiedBy = _data["lastModifiedBy"];
      this.createdAt = _data["createdAt"]
        ? moment(_data["createdAt"].toString())
        : <any>undefined;
      this.lastModifiedAt = _data["lastModifiedAt"]
        ? moment(_data["lastModifiedAt"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): EntityBaseOfGuid {
    data = typeof data === "object" ? data : {};
    throw new Error(
      "The abstract class 'EntityBaseOfGuid' cannot be instantiated."
    );
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.events)) {
      data["events"] = [];
      for (let item of this.events) data["events"].push(item.toJSON());
    }
    data["id"] = this.id;
    data["createdBy"] = this.createdBy;
    data["lastModifiedBy"] = this.lastModifiedBy;
    data["createdAt"] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    data["lastModifiedAt"] = this.lastModifiedAt
      ? this.lastModifiedAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IEntityBaseOfGuid {
  events?: BaseDomainEvent[] | undefined;
  id: string;
  createdBy?: string | undefined;
  lastModifiedBy?: string | undefined;
  createdAt: moment.Moment;
  lastModifiedAt?: moment.Moment | undefined;
}

export class Category extends EntityBaseOfGuid implements ICategory {
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId!: string;
  isEnable!: boolean;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  restaurant?: Restaurant | undefined;
  products?: Product[] | undefined;
  categoryAvailabilities?: CategoryAvailability[] | undefined;
  displayOrder?: number | undefined;
  tenantId?: string | undefined;

  constructor(data?: ICategory) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.shortDescription = _data["shortDescription"];
      this.longDescription = _data["longDescription"];
      this.imagePath = _data["imagePath"];
      this.restaurantId = _data["restaurantId"];
      this.isEnable = _data["isEnable"];
      this.deleteAt = _data["deleteAt"]
        ? moment(_data["deleteAt"].toString())
        : <any>undefined;
      this.availableFrom = _data["availableFrom"]
        ? moment(_data["availableFrom"].toString())
        : <any>undefined;
      this.availableTo = _data["availableTo"]
        ? moment(_data["availableTo"].toString())
        : <any>undefined;
      this.restaurant = _data["restaurant"]
        ? Restaurant.fromJS(_data["restaurant"])
        : <any>undefined;
      if (Array.isArray(_data["products"])) {
        this.products = [] as any;
        for (let item of _data["products"])
          this.products!.push(Product.fromJS(item));
      }
      if (Array.isArray(_data["categoryAvailabilities"])) {
        this.categoryAvailabilities = [] as any;
        for (let item of _data["categoryAvailabilities"])
          this.categoryAvailabilities!.push(CategoryAvailability.fromJS(item));
      }
      this.displayOrder = _data["displayOrder"];
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): Category {
    data = typeof data === "object" ? data : {};
    let result = new Category();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["shortDescription"] = this.shortDescription;
    data["longDescription"] = this.longDescription;
    data["imagePath"] = this.imagePath;
    data["restaurantId"] = this.restaurantId;
    data["isEnable"] = this.isEnable;
    data["deleteAt"] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data["availableFrom"] = this.availableFrom
      ? this.availableFrom.toISOString()
      : <any>undefined;
    data["availableTo"] = this.availableTo
      ? this.availableTo.toISOString()
      : <any>undefined;
    data["restaurant"] = this.restaurant
      ? this.restaurant.toJSON()
      : <any>undefined;
    if (Array.isArray(this.products)) {
      data["products"] = [];
      for (let item of this.products) data["products"].push(item.toJSON());
    }
    if (Array.isArray(this.categoryAvailabilities)) {
      data["categoryAvailabilities"] = [];
      for (let item of this.categoryAvailabilities)
        data["categoryAvailabilities"].push(item.toJSON());
    }
    data["displayOrder"] = this.displayOrder;
    data["tenantId"] = this.tenantId;
    super.toJSON(data);
    return data;
  }
}

export interface ICategory extends IEntityBaseOfGuid {
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId: string;
  isEnable: boolean;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  restaurant?: Restaurant | undefined;
  products?: Product[] | undefined;
  categoryAvailabilities?: CategoryAvailability[] | undefined;
  displayOrder?: number | undefined;
  tenantId?: string | undefined;
}

export class Restaurant extends EntityBaseOfGuid implements IRestaurant {
  userId?: number | undefined;
  user?: User | undefined;
  name?: string | undefined;
  phoneNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
  stripePublicKey?: string | undefined;
  stripePrivateKey?: string | undefined;
  categories?: Category[] | undefined;
  paymentOptions?: PaymentOption[] | undefined;
  tenantId?: string | undefined;

  constructor(data?: IRestaurant) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.userId = _data["userId"];
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
      this.name = _data["name"];
      this.phoneNo = _data["phoneNo"];
      this.address = _data["address"];
      this.postalCode = _data["postalCode"];
      this.email = _data["email"];
      this.image = _data["image"];
      this.stripePublicKey = _data["stripePublicKey"];
      this.stripePrivateKey = _data["stripePrivateKey"];
      if (Array.isArray(_data["categories"])) {
        this.categories = [] as any;
        for (let item of _data["categories"])
          this.categories!.push(Category.fromJS(item));
      }
      if (Array.isArray(_data["paymentOptions"])) {
        this.paymentOptions = [] as any;
        for (let item of _data["paymentOptions"])
          this.paymentOptions!.push(PaymentOption.fromJS(item));
      }
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): Restaurant {
    data = typeof data === "object" ? data : {};
    let result = new Restaurant();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["name"] = this.name;
    data["phoneNo"] = this.phoneNo;
    data["address"] = this.address;
    data["postalCode"] = this.postalCode;
    data["email"] = this.email;
    data["image"] = this.image;
    data["stripePublicKey"] = this.stripePublicKey;
    data["stripePrivateKey"] = this.stripePrivateKey;
    if (Array.isArray(this.categories)) {
      data["categories"] = [];
      for (let item of this.categories) data["categories"].push(item.toJSON());
    }
    if (Array.isArray(this.paymentOptions)) {
      data["paymentOptions"] = [];
      for (let item of this.paymentOptions)
        data["paymentOptions"].push(item.toJSON());
    }
    data["tenantId"] = this.tenantId;
    super.toJSON(data);
    return data;
  }
}

export interface IRestaurant extends IEntityBaseOfGuid {
  userId?: number | undefined;
  user?: User | undefined;
  name?: string | undefined;
  phoneNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
  stripePublicKey?: string | undefined;
  stripePrivateKey?: string | undefined;
  categories?: Category[] | undefined;
  paymentOptions?: PaymentOption[] | undefined;
  tenantId?: string | undefined;
}

export abstract class EntityBaseOfInteger implements IEntityBaseOfInteger {
  events?: BaseDomainEvent[] | undefined;
  id!: number;
  createdBy?: string | undefined;
  lastModifiedBy?: string | undefined;
  createdAt!: moment.Moment;
  lastModifiedAt?: moment.Moment | undefined;

  constructor(data?: IEntityBaseOfInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["events"])) {
        this.events = [] as any;
        for (let item of _data["events"])
          this.events!.push(BaseDomainEvent.fromJS(item));
      }
      this.id = _data["id"];
      this.createdBy = _data["createdBy"];
      this.lastModifiedBy = _data["lastModifiedBy"];
      this.createdAt = _data["createdAt"]
        ? moment(_data["createdAt"].toString())
        : <any>undefined;
      this.lastModifiedAt = _data["lastModifiedAt"]
        ? moment(_data["lastModifiedAt"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): EntityBaseOfInteger {
    data = typeof data === "object" ? data : {};
    throw new Error(
      "The abstract class 'EntityBaseOfInteger' cannot be instantiated."
    );
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.events)) {
      data["events"] = [];
      for (let item of this.events) data["events"].push(item.toJSON());
    }
    data["id"] = this.id;
    data["createdBy"] = this.createdBy;
    data["lastModifiedBy"] = this.lastModifiedBy;
    data["createdAt"] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    data["lastModifiedAt"] = this.lastModifiedAt
      ? this.lastModifiedAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IEntityBaseOfInteger {
  events?: BaseDomainEvent[] | undefined;
  id: number;
  createdBy?: string | undefined;
  lastModifiedBy?: string | undefined;
  createdAt: moment.Moment;
  lastModifiedAt?: moment.Moment | undefined;
}

export class User extends EntityBaseOfInteger implements IUser {
  identityId?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  address?: string | undefined;
  phoneNumber?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  wishLists?: WishList[] | undefined;

  constructor(data?: IUser) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.identityId = _data["identityId"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.address = _data["address"];
      this.phoneNumber = _data["phoneNumber"];
      this.postalCode = _data["postalCode"];
      this.email = _data["email"];
      if (Array.isArray(_data["wishLists"])) {
        this.wishLists = [] as any;
        for (let item of _data["wishLists"])
          this.wishLists!.push(WishList.fromJS(item));
      }
    }
  }

  static fromJS(data: any): User {
    data = typeof data === "object" ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["identityId"] = this.identityId;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["address"] = this.address;
    data["phoneNumber"] = this.phoneNumber;
    data["postalCode"] = this.postalCode;
    data["email"] = this.email;
    if (Array.isArray(this.wishLists)) {
      data["wishLists"] = [];
      for (let item of this.wishLists) data["wishLists"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IUser extends IEntityBaseOfInteger {
  identityId?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  address?: string | undefined;
  phoneNumber?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  wishLists?: WishList[] | undefined;
}

export class WishList extends EntityBaseOfInteger implements IWishList {
  restaurantId!: string;
  userId?: string | undefined;
  productId!: string;
  product?: Product | undefined;
  user?: User | undefined;
  restaurant?: Restaurant | undefined;
  deletedAt?: moment.Moment | undefined;
  tenantId?: string | undefined;

  constructor(data?: IWishList) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.restaurantId = _data["restaurantId"];
      this.userId = _data["userId"];
      this.productId = _data["productId"];
      this.product = _data["product"]
        ? Product.fromJS(_data["product"])
        : <any>undefined;
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
      this.restaurant = _data["restaurant"]
        ? Restaurant.fromJS(_data["restaurant"])
        : <any>undefined;
      this.deletedAt = _data["deletedAt"]
        ? moment(_data["deletedAt"].toString())
        : <any>undefined;
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): WishList {
    data = typeof data === "object" ? data : {};
    let result = new WishList();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["restaurantId"] = this.restaurantId;
    data["userId"] = this.userId;
    data["productId"] = this.productId;
    data["product"] = this.product ? this.product.toJSON() : <any>undefined;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["restaurant"] = this.restaurant
      ? this.restaurant.toJSON()
      : <any>undefined;
    data["deletedAt"] = this.deletedAt
      ? this.deletedAt.toISOString()
      : <any>undefined;
    data["tenantId"] = this.tenantId;
    super.toJSON(data);
    return data;
  }
}

export interface IWishList extends IEntityBaseOfInteger {
  restaurantId: string;
  userId?: string | undefined;
  productId: string;
  product?: Product | undefined;
  user?: User | undefined;
  restaurant?: Restaurant | undefined;
  deletedAt?: moment.Moment | undefined;
  tenantId?: string | undefined;
}

export class Product extends EntityBaseOfGuid implements IProduct {
  name?: string | undefined;
  description?: string | undefined;
  summary?: string | undefined;
  unitPrice?: number | undefined;
  offerPrice?: number | undefined;
  toppingPrice?: number | undefined;
  rate?: number | undefined;
  categoryId!: string;
  isEnable?: boolean | undefined;
  isParent?: boolean | undefined;
  isAddon?: boolean | undefined;
  parentId?: string | undefined;
  mainImage?: string | undefined;
  categoryPortionId?: string | undefined;
  toppingId?: string | undefined;
  deleteAt?: moment.Moment | undefined;
  category?: Category | undefined;
  portionSizeId?: number | undefined;
  portionSize?: PortionSize | undefined;
  categoryPortion?: CategoryPortion | undefined;
  topping?: Topping | undefined;
  wishLists?: WishList[] | undefined;
  ingredient?: string | undefined;
  displayOrder?: number | undefined;
  isSoldOut!: boolean;
  isDeliverable!: boolean;
  tenantId?: string | undefined;

  constructor(data?: IProduct) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.summary = _data["summary"];
      this.unitPrice = _data["unitPrice"];
      this.offerPrice = _data["offerPrice"];
      this.toppingPrice = _data["toppingPrice"];
      this.rate = _data["rate"];
      this.categoryId = _data["categoryId"];
      this.isEnable = _data["isEnable"];
      this.isParent = _data["isParent"];
      this.isAddon = _data["isAddon"];
      this.parentId = _data["parentId"];
      this.mainImage = _data["mainImage"];
      this.categoryPortionId = _data["categoryPortionId"];
      this.toppingId = _data["toppingId"];
      this.deleteAt = _data["deleteAt"]
        ? moment(_data["deleteAt"].toString())
        : <any>undefined;
      this.category = _data["category"]
        ? Category.fromJS(_data["category"])
        : <any>undefined;
      this.portionSizeId = _data["portionSizeId"];
      this.portionSize = _data["portionSize"]
        ? PortionSize.fromJS(_data["portionSize"])
        : <any>undefined;
      this.categoryPortion = _data["categoryPortion"]
        ? CategoryPortion.fromJS(_data["categoryPortion"])
        : <any>undefined;
      this.topping = _data["topping"]
        ? Topping.fromJS(_data["topping"])
        : <any>undefined;
      if (Array.isArray(_data["wishLists"])) {
        this.wishLists = [] as any;
        for (let item of _data["wishLists"])
          this.wishLists!.push(WishList.fromJS(item));
      }
      this.ingredient = _data["ingredient"];
      this.displayOrder = _data["displayOrder"];
      this.isSoldOut = _data["isSoldOut"];
      this.isDeliverable = _data["isDeliverable"];
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): Product {
    data = typeof data === "object" ? data : {};
    let result = new Product();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["summary"] = this.summary;
    data["unitPrice"] = this.unitPrice;
    data["offerPrice"] = this.offerPrice;
    data["toppingPrice"] = this.toppingPrice;
    data["rate"] = this.rate;
    data["categoryId"] = this.categoryId;
    data["isEnable"] = this.isEnable;
    data["isParent"] = this.isParent;
    data["isAddon"] = this.isAddon;
    data["parentId"] = this.parentId;
    data["mainImage"] = this.mainImage;
    data["categoryPortionId"] = this.categoryPortionId;
    data["toppingId"] = this.toppingId;
    data["deleteAt"] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    data["portionSizeId"] = this.portionSizeId;
    data["portionSize"] = this.portionSize
      ? this.portionSize.toJSON()
      : <any>undefined;
    data["categoryPortion"] = this.categoryPortion
      ? this.categoryPortion.toJSON()
      : <any>undefined;
    data["topping"] = this.topping ? this.topping.toJSON() : <any>undefined;
    if (Array.isArray(this.wishLists)) {
      data["wishLists"] = [];
      for (let item of this.wishLists) data["wishLists"].push(item.toJSON());
    }
    data["ingredient"] = this.ingredient;
    data["displayOrder"] = this.displayOrder;
    data["isSoldOut"] = this.isSoldOut;
    data["isDeliverable"] = this.isDeliverable;
    data["tenantId"] = this.tenantId;
    super.toJSON(data);
    return data;
  }
}

export interface IProduct extends IEntityBaseOfGuid {
  name?: string | undefined;
  description?: string | undefined;
  summary?: string | undefined;
  unitPrice?: number | undefined;
  offerPrice?: number | undefined;
  toppingPrice?: number | undefined;
  rate?: number | undefined;
  categoryId: string;
  isEnable?: boolean | undefined;
  isParent?: boolean | undefined;
  isAddon?: boolean | undefined;
  parentId?: string | undefined;
  mainImage?: string | undefined;
  categoryPortionId?: string | undefined;
  toppingId?: string | undefined;
  deleteAt?: moment.Moment | undefined;
  category?: Category | undefined;
  portionSizeId?: number | undefined;
  portionSize?: PortionSize | undefined;
  categoryPortion?: CategoryPortion | undefined;
  topping?: Topping | undefined;
  wishLists?: WishList[] | undefined;
  ingredient?: string | undefined;
  displayOrder?: number | undefined;
  isSoldOut: boolean;
  isDeliverable: boolean;
  tenantId?: string | undefined;
}

export class PortionSize extends EntityBaseOfInteger implements IPortionSize {
  name?: string | undefined;
  restaurantId!: string;
  restaurant?: Restaurant | undefined;
  deletedAt?: moment.Moment | undefined;
  tenantId?: string | undefined;

  constructor(data?: IPortionSize) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.restaurantId = _data["restaurantId"];
      this.restaurant = _data["restaurant"]
        ? Restaurant.fromJS(_data["restaurant"])
        : <any>undefined;
      this.deletedAt = _data["deletedAt"]
        ? moment(_data["deletedAt"].toString())
        : <any>undefined;
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): PortionSize {
    data = typeof data === "object" ? data : {};
    let result = new PortionSize();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["restaurantId"] = this.restaurantId;
    data["restaurant"] = this.restaurant
      ? this.restaurant.toJSON()
      : <any>undefined;
    data["deletedAt"] = this.deletedAt
      ? this.deletedAt.toISOString()
      : <any>undefined;
    data["tenantId"] = this.tenantId;
    super.toJSON(data);
    return data;
  }
}

export interface IPortionSize extends IEntityBaseOfInteger {
  name?: string | undefined;
  restaurantId: string;
  restaurant?: Restaurant | undefined;
  deletedAt?: moment.Moment | undefined;
  tenantId?: string | undefined;
}

export abstract class BaseDomainEvent implements IBaseDomainEvent {
  dateOccurred!: moment.Moment;

  constructor(data?: IBaseDomainEvent) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dateOccurred = _data["dateOccurred"]
        ? moment(_data["dateOccurred"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): BaseDomainEvent {
    data = typeof data === "object" ? data : {};
    throw new Error(
      "The abstract class 'BaseDomainEvent' cannot be instantiated."
    );
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["dateOccurred"] = this.dateOccurred
      ? this.dateOccurred.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IBaseDomainEvent {
  dateOccurred: moment.Moment;
}

export class CategoryPortion
  extends EntityBaseOfGuid
  implements ICategoryPortion {
  portionsName?: string | undefined;
  portionSizeId!: number;
  portionSize?: PortionSize | undefined;
  categoryId!: string;
  category?: Category | undefined;

  constructor(data?: ICategoryPortion) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.portionsName = _data["portionsName"];
      this.portionSizeId = _data["portionSizeId"];
      this.portionSize = _data["portionSize"]
        ? PortionSize.fromJS(_data["portionSize"])
        : <any>undefined;
      this.categoryId = _data["categoryId"];
      this.category = _data["category"]
        ? Category.fromJS(_data["category"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CategoryPortion {
    data = typeof data === "object" ? data : {};
    let result = new CategoryPortion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["portionsName"] = this.portionsName;
    data["portionSizeId"] = this.portionSizeId;
    data["portionSize"] = this.portionSize
      ? this.portionSize.toJSON()
      : <any>undefined;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface ICategoryPortion extends IEntityBaseOfGuid {
  portionsName?: string | undefined;
  portionSizeId: number;
  portionSize?: PortionSize | undefined;
  categoryId: string;
  category?: Category | undefined;
}

export class Topping extends EntityBaseOfGuid implements ITopping {
  name?: string | undefined;
  price!: number;
  isEnable!: boolean;
  deletedAt?: moment.Moment | undefined;
  restaurantId!: string;
  restaurant?: Restaurant | undefined;
  addonCategories?: AddonCategory[] | undefined;
  tenantId?: string | undefined;

  constructor(data?: ITopping) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.price = _data["price"];
      this.isEnable = _data["isEnable"];
      this.deletedAt = _data["deletedAt"]
        ? moment(_data["deletedAt"].toString())
        : <any>undefined;
      this.restaurantId = _data["restaurantId"];
      this.restaurant = _data["restaurant"]
        ? Restaurant.fromJS(_data["restaurant"])
        : <any>undefined;
      if (Array.isArray(_data["addonCategories"])) {
        this.addonCategories = [] as any;
        for (let item of _data["addonCategories"])
          this.addonCategories!.push(AddonCategory.fromJS(item));
      }
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): Topping {
    data = typeof data === "object" ? data : {};
    let result = new Topping();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["price"] = this.price;
    data["isEnable"] = this.isEnable;
    data["deletedAt"] = this.deletedAt
      ? this.deletedAt.toISOString()
      : <any>undefined;
    data["restaurantId"] = this.restaurantId;
    data["restaurant"] = this.restaurant
      ? this.restaurant.toJSON()
      : <any>undefined;
    if (Array.isArray(this.addonCategories)) {
      data["addonCategories"] = [];
      for (let item of this.addonCategories)
        data["addonCategories"].push(item.toJSON());
    }
    data["tenantId"] = this.tenantId;
    super.toJSON(data);
    return data;
  }
}

export interface ITopping extends IEntityBaseOfGuid {
  name?: string | undefined;
  price: number;
  isEnable: boolean;
  deletedAt?: moment.Moment | undefined;
  restaurantId: string;
  restaurant?: Restaurant | undefined;
  addonCategories?: AddonCategory[] | undefined;
  tenantId?: string | undefined;
}

export class AddonCategory extends EntityBaseOfGuid implements IAddonCategory {
  toppingId!: string;
  topping?: Topping | undefined;
  categoryId!: string;
  category?: Category | undefined;

  constructor(data?: IAddonCategory) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.toppingId = _data["toppingId"];
      this.topping = _data["topping"]
        ? Topping.fromJS(_data["topping"])
        : <any>undefined;
      this.categoryId = _data["categoryId"];
      this.category = _data["category"]
        ? Category.fromJS(_data["category"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddonCategory {
    data = typeof data === "object" ? data : {};
    let result = new AddonCategory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["toppingId"] = this.toppingId;
    data["topping"] = this.topping ? this.topping.toJSON() : <any>undefined;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IAddonCategory extends IEntityBaseOfGuid {
  toppingId: string;
  topping?: Topping | undefined;
  categoryId: string;
  category?: Category | undefined;
}

export class PaymentOption extends EntityBaseOfGuid implements IPaymentOption {
  restaurantId!: string;
  restaurant?: Restaurant | undefined;
  optionId?: string | undefined;
  name?: string | undefined;
  publicKey?: string | undefined;
  secretKey?: string | undefined;
  tenantId?: string | undefined;

  constructor(data?: IPaymentOption) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.restaurantId = _data["restaurantId"];
      this.restaurant = _data["restaurant"]
        ? Restaurant.fromJS(_data["restaurant"])
        : <any>undefined;
      this.optionId = _data["optionId"];
      this.name = _data["name"];
      this.publicKey = _data["publicKey"];
      this.secretKey = _data["secretKey"];
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): PaymentOption {
    data = typeof data === "object" ? data : {};
    let result = new PaymentOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["restaurantId"] = this.restaurantId;
    data["restaurant"] = this.restaurant
      ? this.restaurant.toJSON()
      : <any>undefined;
    data["optionId"] = this.optionId;
    data["name"] = this.name;
    data["publicKey"] = this.publicKey;
    data["secretKey"] = this.secretKey;
    data["tenantId"] = this.tenantId;
    super.toJSON(data);
    return data;
  }
}

export interface IPaymentOption extends IEntityBaseOfGuid {
  restaurantId: string;
  restaurant?: Restaurant | undefined;
  optionId?: string | undefined;
  name?: string | undefined;
  publicKey?: string | undefined;
  secretKey?: string | undefined;
  tenantId?: string | undefined;
}

export class CategoryAvailability
  extends EntityBaseOfGuid
  implements ICategoryAvailability {
  categoryId!: string;
  date?: string | undefined;
  from!: moment.Moment;
  to!: moment.Moment;

  constructor(data?: ICategoryAvailability) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.categoryId = _data["categoryId"];
      this.date = _data["date"];
      this.from = _data["from"]
        ? moment(_data["from"].toString())
        : <any>undefined;
      this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): CategoryAvailability {
    data = typeof data === "object" ? data : {};
    let result = new CategoryAvailability();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryId"] = this.categoryId;
    data["date"] = this.date;
    data["from"] = this.from ? this.from.toISOString() : <any>undefined;
    data["to"] = this.to ? this.to.toISOString() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface ICategoryAvailability extends IEntityBaseOfGuid {
  categoryId: string;
  date?: string | undefined;
  from: moment.Moment;
  to: moment.Moment;
}

export class CategoryPortionModel implements ICategoryPortionModel {
  id?: string | undefined;
  portionsNAme?: string | undefined;
  portionSizeId!: number;
  portionSize?: PortionSizeModel | undefined;
  categoryId?: string | undefined;
  category?: CategoryModel | undefined;
  offerPrice!: number;
  regularPrice!: number;

  constructor(data?: ICategoryPortionModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.portionsNAme = _data["portionsNAme"];
      this.portionSizeId = _data["portionSizeId"];
      this.portionSize = _data["portionSize"]
        ? PortionSizeModel.fromJS(_data["portionSize"])
        : <any>undefined;
      this.categoryId = _data["categoryId"];
      this.category = _data["category"]
        ? CategoryModel.fromJS(_data["category"])
        : <any>undefined;
      this.offerPrice = _data["offerPrice"];
      this.regularPrice = _data["regularPrice"];
    }
  }

  static fromJS(data: any): CategoryPortionModel {
    data = typeof data === "object" ? data : {};
    let result = new CategoryPortionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["portionsNAme"] = this.portionsNAme;
    data["portionSizeId"] = this.portionSizeId;
    data["portionSize"] = this.portionSize
      ? this.portionSize.toJSON()
      : <any>undefined;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    data["offerPrice"] = this.offerPrice;
    data["regularPrice"] = this.regularPrice;
    return data;
  }
}

export interface ICategoryPortionModel {
  id?: string | undefined;
  portionsNAme?: string | undefined;
  portionSizeId: number;
  portionSize?: PortionSizeModel | undefined;
  categoryId?: string | undefined;
  category?: CategoryModel | undefined;
  offerPrice: number;
  regularPrice: number;
}

export class PortionSizeModel extends BaseModel implements IPortionSizeModel {
  id!: number;
  name?: string | undefined;
  restaurantId?: string | undefined;
  category?: CategoryModel | undefined;
  restaurant?: RestaurantModel | undefined;
  deletedAt?: moment.Moment | undefined;

  constructor(data?: IPortionSizeModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.restaurantId = _data["restaurantId"];
      this.category = _data["category"]
        ? CategoryModel.fromJS(_data["category"])
        : <any>undefined;
      this.restaurant = _data["restaurant"]
        ? RestaurantModel.fromJS(_data["restaurant"])
        : <any>undefined;
      this.deletedAt = _data["deletedAt"]
        ? moment(_data["deletedAt"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): PortionSizeModel {
    data = typeof data === "object" ? data : {};
    let result = new PortionSizeModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["restaurantId"] = this.restaurantId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    data["restaurant"] = this.restaurant
      ? this.restaurant.toJSON()
      : <any>undefined;
    data["deletedAt"] = this.deletedAt
      ? this.deletedAt.toISOString()
      : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

export interface IPortionSizeModel extends IBaseModel {
  id: number;
  name?: string | undefined;
  restaurantId?: string | undefined;
  category?: CategoryModel | undefined;
  restaurant?: RestaurantModel | undefined;
  deletedAt?: moment.Moment | undefined;
}

export class RestaurantModel implements IRestaurantModel {
  id?: string | undefined;
  userId?: number | undefined;
  user?: UserModel | undefined;
  name?: string | undefined;
  phoneNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
  categories?: CategoryModel[] | undefined;
  paymentOptions?: PaymentOptionModel[] | undefined;

  constructor(data?: IRestaurantModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.userId = _data["userId"];
      this.user = _data["user"]
        ? UserModel.fromJS(_data["user"])
        : <any>undefined;
      this.name = _data["name"];
      this.phoneNo = _data["phoneNo"];
      this.address = _data["address"];
      this.postalCode = _data["postalCode"];
      this.email = _data["email"];
      this.image = _data["image"];
      if (Array.isArray(_data["categories"])) {
        this.categories = [] as any;
        for (let item of _data["categories"])
          this.categories!.push(CategoryModel.fromJS(item));
      }
      if (Array.isArray(_data["paymentOptions"])) {
        this.paymentOptions = [] as any;
        for (let item of _data["paymentOptions"])
          this.paymentOptions!.push(PaymentOptionModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RestaurantModel {
    data = typeof data === "object" ? data : {};
    let result = new RestaurantModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["name"] = this.name;
    data["phoneNo"] = this.phoneNo;
    data["address"] = this.address;
    data["postalCode"] = this.postalCode;
    data["email"] = this.email;
    data["image"] = this.image;
    if (Array.isArray(this.categories)) {
      data["categories"] = [];
      for (let item of this.categories) data["categories"].push(item.toJSON());
    }
    if (Array.isArray(this.paymentOptions)) {
      data["paymentOptions"] = [];
      for (let item of this.paymentOptions)
        data["paymentOptions"].push(item.toJSON());
    }
    return data;
  }
}

export interface IRestaurantModel {
  id?: string | undefined;
  userId?: number | undefined;
  user?: UserModel | undefined;
  name?: string | undefined;
  phoneNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  email?: string | undefined;
  image?: string | undefined;
  categories?: CategoryModel[] | undefined;
  paymentOptions?: PaymentOptionModel[] | undefined;
}

export class UserModel extends BaseModel implements IUserModel {
  identityId?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  address?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
  wishLists?: WishList[] | undefined;

  constructor(data?: IUserModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.identityId = _data["identityId"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.address = _data["address"];
      this.phoneNumber = _data["phoneNumber"];
      this.email = _data["email"];
      if (Array.isArray(_data["wishLists"])) {
        this.wishLists = [] as any;
        for (let item of _data["wishLists"])
          this.wishLists!.push(WishList.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserModel {
    data = typeof data === "object" ? data : {};
    let result = new UserModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["identityId"] = this.identityId;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["address"] = this.address;
    data["phoneNumber"] = this.phoneNumber;
    data["email"] = this.email;
    if (Array.isArray(this.wishLists)) {
      data["wishLists"] = [];
      for (let item of this.wishLists) data["wishLists"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface IUserModel extends IBaseModel {
  identityId?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  address?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
  wishLists?: WishList[] | undefined;
}

export class PaymentOptionModel
  extends BaseModel
  implements IPaymentOptionModel {
  id?: string | undefined;
  restaurantId?: string | undefined;
  restaurant?: RestaurantModel | undefined;
  optionId?: string | undefined;
  name!: string;
  publicKey!: string;
  secretKey!: string;

  constructor(data?: IPaymentOptionModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.restaurantId = _data["restaurantId"];
      this.restaurant = _data["restaurant"]
        ? RestaurantModel.fromJS(_data["restaurant"])
        : <any>undefined;
      this.optionId = _data["optionId"];
      this.name = _data["name"];
      this.publicKey = _data["publicKey"];
      this.secretKey = _data["secretKey"];
    }
  }

  static fromJS(data: any): PaymentOptionModel {
    data = typeof data === "object" ? data : {};
    let result = new PaymentOptionModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["restaurantId"] = this.restaurantId;
    data["restaurant"] = this.restaurant
      ? this.restaurant.toJSON()
      : <any>undefined;
    data["optionId"] = this.optionId;
    data["name"] = this.name;
    data["publicKey"] = this.publicKey;
    data["secretKey"] = this.secretKey;
    super.toJSON(data);
    return data;
  }
}

export interface IPaymentOptionModel extends IBaseModel {
  id?: string | undefined;
  restaurantId?: string | undefined;
  restaurant?: RestaurantModel | undefined;
  optionId?: string | undefined;
  name: string;
  publicKey: string;
  secretKey: string;
}

export abstract class MarshalByRefObject implements IMarshalByRefObject {
  constructor(data?: IMarshalByRefObject) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): MarshalByRefObject {
    data = typeof data === "object" ? data : {};
    throw new Error(
      "The abstract class 'MarshalByRefObject' cannot be instantiated."
    );
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IMarshalByRefObject {}

export abstract class Stream extends MarshalByRefObject implements IStream {
  canTimeout!: boolean;
  readTimeout!: number;
  writeTimeout!: number;

  constructor(data?: IStream) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.canTimeout = _data["canTimeout"];
      this.readTimeout = _data["readTimeout"];
      this.writeTimeout = _data["writeTimeout"];
    }
  }

  static fromJS(data: any): Stream {
    data = typeof data === "object" ? data : {};
    throw new Error("The abstract class 'Stream' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canTimeout"] = this.canTimeout;
    data["readTimeout"] = this.readTimeout;
    data["writeTimeout"] = this.writeTimeout;
    super.toJSON(data);
    return data;
  }
}

export interface IStream extends IMarshalByRefObject {
  canTimeout: boolean;
  readTimeout: number;
  writeTimeout: number;
}

export class MemoryStream extends Stream implements IMemoryStream {
  canRead!: boolean;
  canSeek!: boolean;
  canWrite!: boolean;
  capacity!: number;
  length!: number;
  position!: number;

  constructor(data?: IMemoryStream) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.canRead = _data["canRead"];
      this.canSeek = _data["canSeek"];
      this.canWrite = _data["canWrite"];
      this.capacity = _data["capacity"];
      this.length = _data["length"];
      this.position = _data["position"];
    }
  }

  static fromJS(data: any): MemoryStream {
    data = typeof data === "object" ? data : {};
    let result = new MemoryStream();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canRead"] = this.canRead;
    data["canSeek"] = this.canSeek;
    data["canWrite"] = this.canWrite;
    data["capacity"] = this.capacity;
    data["length"] = this.length;
    data["position"] = this.position;
    super.toJSON(data);
    return data;
  }
}

export interface IMemoryStream extends IStream {
  canRead: boolean;
  canSeek: boolean;
  canWrite: boolean;
  capacity: number;
  length: number;
  position: number;
}

export class CategoryAvailabilityModel implements ICategoryAvailabilityModel {
  id?: string | undefined;
  categoryId?: string | undefined;
  date?: string | undefined;
  from!: moment.Moment;
  to!: moment.Moment;

  constructor(data?: ICategoryAvailabilityModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.categoryId = _data["categoryId"];
      this.date = _data["date"];
      this.from = _data["from"]
        ? moment(_data["from"].toString())
        : <any>undefined;
      this.to = _data["to"] ? moment(_data["to"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): CategoryAvailabilityModel {
    data = typeof data === "object" ? data : {};
    let result = new CategoryAvailabilityModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["categoryId"] = this.categoryId;
    data["date"] = this.date;
    data["from"] = this.from ? this.from.toISOString() : <any>undefined;
    data["to"] = this.to ? this.to.toISOString() : <any>undefined;
    return data;
  }
}

export interface ICategoryAvailabilityModel {
  id?: string | undefined;
  categoryId?: string | undefined;
  date?: string | undefined;
  from: moment.Moment;
  to: moment.Moment;
}

export class ResponseOfGetAddOnResponse implements IResponseOfGetAddOnResponse {
  data?: GetAddOnResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfGetAddOnResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? GetAddOnResponse.fromJS(_data["data"])
        : <any>undefined;
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfGetAddOnResponse {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfGetAddOnResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfGetAddOnResponse {
  data?: GetAddOnResponse | undefined;
  _links?: LinkBase | undefined;
}

export class UpdateAddOnRequest implements IUpdateAddOnRequest {
  id?: string | undefined;
  name?: string | undefined;
  price!: number;
  isEnable?: boolean | undefined;
  toppingModel?: ToppingModel | undefined;

  constructor(data?: IUpdateAddOnRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.price = _data["price"];
      this.isEnable = _data["isEnable"];
      this.toppingModel = _data["toppingModel"]
        ? ToppingModel.fromJS(_data["toppingModel"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateAddOnRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAddOnRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["price"] = this.price;
    data["isEnable"] = this.isEnable;
    data["toppingModel"] = this.toppingModel
      ? this.toppingModel.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IUpdateAddOnRequest {
  id?: string | undefined;
  name?: string | undefined;
  price: number;
  isEnable?: boolean | undefined;
  toppingModel?: ToppingModel | undefined;
}

export class PagedResponseOfGetCategoryContractResponse
  implements IPagedResponseOfGetCategoryContractResponse {
  data?: GetCategoryContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;

  constructor(data?: IPagedResponseOfGetCategoryContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(GetCategoryContractResponse.fromJS(item));
      }
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this._links = _data["_links"]
        ? Links.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PagedResponseOfGetCategoryContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new PagedResponseOfGetCategoryContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data) data["data"].push(item.toJSON());
    }
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IPagedResponseOfGetCategoryContractResponse {
  data?: GetCategoryContractResponse[] | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  _links?: Links | undefined;
}

export class GetCategoryContractResponse
  implements IGetCategoryContractResponse {
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId?: string | undefined;
  isEnable?: boolean | undefined;
  displayOrder?: number | undefined;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  image?: MemoryStream | undefined;
  portionIds?: number[] | undefined;

  constructor(data?: IGetCategoryContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.shortDescription = _data["shortDescription"];
      this.longDescription = _data["longDescription"];
      this.imagePath = _data["imagePath"];
      this.restaurantId = _data["restaurantId"];
      this.isEnable = _data["isEnable"];
      this.displayOrder = _data["displayOrder"];
      this.deleteAt = _data["deleteAt"]
        ? moment(_data["deleteAt"].toString())
        : <any>undefined;
      this.availableFrom = _data["availableFrom"]
        ? moment(_data["availableFrom"].toString())
        : <any>undefined;
      this.availableTo = _data["availableTo"]
        ? moment(_data["availableTo"].toString())
        : <any>undefined;
      this.image = _data["image"]
        ? MemoryStream.fromJS(_data["image"])
        : <any>undefined;
      if (Array.isArray(_data["portionIds"])) {
        this.portionIds = [] as any;
        for (let item of _data["portionIds"]) this.portionIds!.push(item);
      }
    }
  }

  static fromJS(data: any): GetCategoryContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetCategoryContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["shortDescription"] = this.shortDescription;
    data["longDescription"] = this.longDescription;
    data["imagePath"] = this.imagePath;
    data["restaurantId"] = this.restaurantId;
    data["isEnable"] = this.isEnable;
    data["displayOrder"] = this.displayOrder;
    data["deleteAt"] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data["availableFrom"] = this.availableFrom
      ? this.availableFrom.toISOString()
      : <any>undefined;
    data["availableTo"] = this.availableTo
      ? this.availableTo.toISOString()
      : <any>undefined;
    data["image"] = this.image ? this.image.toJSON() : <any>undefined;
    if (Array.isArray(this.portionIds)) {
      data["portionIds"] = [];
      for (let item of this.portionIds) data["portionIds"].push(item);
    }
    return data;
  }
}

export interface IGetCategoryContractResponse {
  name?: string | undefined;
  shortDescription?: string | undefined;
  longDescription?: string | undefined;
  imagePath?: string | undefined;
  restaurantId?: string | undefined;
  isEnable?: boolean | undefined;
  displayOrder?: number | undefined;
  deleteAt?: moment.Moment | undefined;
  availableFrom?: moment.Moment | undefined;
  availableTo?: moment.Moment | undefined;
  image?: MemoryStream | undefined;
  portionIds?: number[] | undefined;
}

export class ResponseOfGetCustomerResponse
  implements IResponseOfGetCustomerResponse {
  data?: GetCustomerResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfGetCustomerResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? GetCustomerResponse.fromJS(_data["data"])
        : <any>undefined;
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfGetCustomerResponse {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfGetCustomerResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfGetCustomerResponse {
  data?: GetCustomerResponse | undefined;
  _links?: LinkBase | undefined;
}

export class GetCustomerResponse implements IGetCustomerResponse {
  customerListModels?: CustomerListModel[] | undefined;

  constructor(data?: IGetCustomerResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["customerListModels"])) {
        this.customerListModels = [] as any;
        for (let item of _data["customerListModels"])
          this.customerListModels!.push(CustomerListModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GetCustomerResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetCustomerResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.customerListModels)) {
      data["customerListModels"] = [];
      for (let item of this.customerListModels)
        data["customerListModels"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGetCustomerResponse {
  customerListModels?: CustomerListModel[] | undefined;
}

export class CustomerListModel implements ICustomerListModel {
  id?: string | undefined;
  userId?: number | undefined;
  user?: UserModel | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  roleId?: string | undefined;
  status?: string | undefined;
  empNo?: string | undefined;
  joinDate!: moment.Moment;
  lastDate!: moment.Moment;
  phoneNo?: string | undefined;
  mobileNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  officeEmail?: string | undefined;
  personalEmail?: string | undefined;
  image?: string | undefined;
  restaurantId?: string | undefined;
  orderCount!: number;
  totalSales!: number;

  constructor(data?: ICustomerListModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.userId = _data["userId"];
      this.user = _data["user"]
        ? UserModel.fromJS(_data["user"])
        : <any>undefined;
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.roleId = _data["roleId"];
      this.status = _data["status"];
      this.empNo = _data["empNo"];
      this.joinDate = _data["joinDate"]
        ? moment(_data["joinDate"].toString())
        : <any>undefined;
      this.lastDate = _data["lastDate"]
        ? moment(_data["lastDate"].toString())
        : <any>undefined;
      this.phoneNo = _data["phoneNo"];
      this.mobileNo = _data["mobileNo"];
      this.address = _data["address"];
      this.postalCode = _data["postalCode"];
      this.officeEmail = _data["officeEmail"];
      this.personalEmail = _data["personalEmail"];
      this.image = _data["image"];
      this.restaurantId = _data["restaurantId"];
      this.orderCount = _data["orderCount"];
      this.totalSales = _data["totalSales"];
    }
  }

  static fromJS(data: any): CustomerListModel {
    data = typeof data === "object" ? data : {};
    let result = new CustomerListModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["roleId"] = this.roleId;
    data["status"] = this.status;
    data["empNo"] = this.empNo;
    data["joinDate"] = this.joinDate
      ? this.joinDate.toISOString()
      : <any>undefined;
    data["lastDate"] = this.lastDate
      ? this.lastDate.toISOString()
      : <any>undefined;
    data["phoneNo"] = this.phoneNo;
    data["mobileNo"] = this.mobileNo;
    data["address"] = this.address;
    data["postalCode"] = this.postalCode;
    data["officeEmail"] = this.officeEmail;
    data["personalEmail"] = this.personalEmail;
    data["image"] = this.image;
    data["restaurantId"] = this.restaurantId;
    data["orderCount"] = this.orderCount;
    data["totalSales"] = this.totalSales;
    return data;
  }
}

export interface ICustomerListModel {
  id?: string | undefined;
  userId?: number | undefined;
  user?: UserModel | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  roleId?: string | undefined;
  status?: string | undefined;
  empNo?: string | undefined;
  joinDate: moment.Moment;
  lastDate: moment.Moment;
  phoneNo?: string | undefined;
  mobileNo?: string | undefined;
  address?: string | undefined;
  postalCode?: string | undefined;
  officeEmail?: string | undefined;
  personalEmail?: string | undefined;
  image?: string | undefined;
  restaurantId?: string | undefined;
  orderCount: number;
  totalSales: number;
}

export class ResponseOfGetDriverContractResponse
  implements IResponseOfGetDriverContractResponse {
  data?: GetDriverContractResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfGetDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? GetDriverContractResponse.fromJS(_data["data"])
        : <any>undefined;
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfGetDriverContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfGetDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfGetDriverContractResponse {
  data?: GetDriverContractResponse | undefined;
  _links?: LinkBase | undefined;
}

export class GetDriverContractResponse implements IGetDriverContractResponse {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;

  constructor(data?: IGetDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.empNo = _data["empNo"];
      this.driverName = _data["driverName"];
      this.address = _data["address"];
      this.city = _data["city"];
      this.telephone = _data["telephone"];
      this.eMail = _data["eMail"];
      this.licence = _data["licence"];
      this.vehicleType = _data["vehicleType"];
      this.vehicleNo = _data["vehicleNo"];
      this.restaurantId = _data["restaurantId"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): GetDriverContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["empNo"] = this.empNo;
    data["driverName"] = this.driverName;
    data["address"] = this.address;
    data["city"] = this.city;
    data["telephone"] = this.telephone;
    data["eMail"] = this.eMail;
    data["licence"] = this.licence;
    data["vehicleType"] = this.vehicleType;
    data["vehicleNo"] = this.vehicleNo;
    data["restaurantId"] = this.restaurantId;
    data["image"] = this.image;
    return data;
  }
}

export interface IGetDriverContractResponse {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;
}

export class ResponseOfUpdateDriverContractResponse
  implements IResponseOfUpdateDriverContractResponse {
  data?: UpdateDriverContractResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfUpdateDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? UpdateDriverContractResponse.fromJS(_data["data"])
        : <any>undefined;
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfUpdateDriverContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfUpdateDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfUpdateDriverContractResponse {
  data?: UpdateDriverContractResponse | undefined;
  _links?: LinkBase | undefined;
}

export class UpdateDriverContractResponse
  implements IUpdateDriverContractResponse {
  id?: string | undefined;
  empNo!: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;

  constructor(data?: IUpdateDriverContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.empNo = _data["empNo"];
      this.driverName = _data["driverName"];
      this.address = _data["address"];
      this.city = _data["city"];
      this.telephone = _data["telephone"];
      this.eMail = _data["eMail"];
      this.licence = _data["licence"];
      this.vehicleType = _data["vehicleType"];
      this.vehicleNo = _data["vehicleNo"];
      this.restaurantId = _data["restaurantId"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): UpdateDriverContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDriverContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["empNo"] = this.empNo;
    data["driverName"] = this.driverName;
    data["address"] = this.address;
    data["city"] = this.city;
    data["telephone"] = this.telephone;
    data["eMail"] = this.eMail;
    data["licence"] = this.licence;
    data["vehicleType"] = this.vehicleType;
    data["vehicleNo"] = this.vehicleNo;
    data["restaurantId"] = this.restaurantId;
    data["image"] = this.image;
    return data;
  }
}

export interface IUpdateDriverContractResponse {
  id?: string | undefined;
  empNo: number;
  driverName?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  telephone?: string | undefined;
  eMail?: string | undefined;
  licence?: string | undefined;
  vehicleType?: string | undefined;
  vehicleNo?: string | undefined;
  restaurantId?: string | undefined;
  image?: string | undefined;
}

export class UpdateDriverContractRequest
  implements IUpdateDriverContractRequest {
  constructor(data?: IUpdateDriverContractRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): UpdateDriverContractRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateDriverContractRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface IUpdateDriverContractRequest {}

export class ResponseOfCreateDriverContractRequest
  implements IResponseOfCreateDriverContractRequest {
  data?: CreateDriverContractRequest | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfCreateDriverContractRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? CreateDriverContractRequest.fromJS(_data["data"])
        : <any>undefined;
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfCreateDriverContractRequest {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfCreateDriverContractRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfCreateDriverContractRequest {
  data?: CreateDriverContractRequest | undefined;
  _links?: LinkBase | undefined;
}

export class CreateDriverContractRequest
  implements ICreateDriverContractRequest {
  constructor(data?: ICreateDriverContractRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): CreateDriverContractRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateDriverContractRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    return data;
  }
}

export interface ICreateDriverContractRequest {}

export class ResponseOfListOfGetOrderContractResponse
  implements IResponseOfListOfGetOrderContractResponse {
  data?: GetOrderContractResponse[] | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfListOfGetOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["data"])) {
        this.data = [] as any;
        for (let item of _data["data"])
          this.data!.push(GetOrderContractResponse.fromJS(item));
      }
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfListOfGetOrderContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfListOfGetOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.data)) {
      data["data"] = [];
      for (let item of this.data) data["data"].push(item.toJSON());
    }
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfListOfGetOrderContractResponse {
  data?: GetOrderContractResponse[] | undefined;
  _links?: LinkBase | undefined;
}

export class GetOrderContractResponse implements IGetOrderContractResponse {
  id?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  phone?: string | undefined;
  displayId?: string | undefined;
  orderDetails?: OrderDetail[] | undefined;
  subTotal?: string | undefined;
  deliveryFee?: string | undefined;
  total?: string | undefined;
  duration?: string | undefined;
  distance?: string | undefined;
  createdAt!: moment.Moment;

  constructor(data?: IGetOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.address = _data["address"];
      this.city = _data["city"];
      this.postalCode = _data["postalCode"];
      this.phone = _data["phone"];
      this.displayId = _data["displayId"];
      if (Array.isArray(_data["orderDetails"])) {
        this.orderDetails = [] as any;
        for (let item of _data["orderDetails"])
          this.orderDetails!.push(OrderDetail.fromJS(item));
      }
      this.subTotal = _data["subTotal"];
      this.deliveryFee = _data["deliveryFee"];
      this.total = _data["total"];
      this.duration = _data["duration"];
      this.distance = _data["distance"];
      this.createdAt = _data["createdAt"]
        ? moment(_data["createdAt"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetOrderContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["address"] = this.address;
    data["city"] = this.city;
    data["postalCode"] = this.postalCode;
    data["phone"] = this.phone;
    data["displayId"] = this.displayId;
    if (Array.isArray(this.orderDetails)) {
      data["orderDetails"] = [];
      for (let item of this.orderDetails)
        data["orderDetails"].push(item.toJSON());
    }
    data["subTotal"] = this.subTotal;
    data["deliveryFee"] = this.deliveryFee;
    data["total"] = this.total;
    data["duration"] = this.duration;
    data["distance"] = this.distance;
    data["createdAt"] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IGetOrderContractResponse {
  id?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  postalCode?: string | undefined;
  phone?: string | undefined;
  displayId?: string | undefined;
  orderDetails?: OrderDetail[] | undefined;
  subTotal?: string | undefined;
  deliveryFee?: string | undefined;
  total?: string | undefined;
  duration?: string | undefined;
  distance?: string | undefined;
  createdAt: moment.Moment;
}

export class OrderDetail implements IOrderDetail {
  id?: string | undefined;
  product?: ProductApiModel | undefined;
  quantity!: number;
  price?: string | undefined;

  constructor(data?: IOrderDetail) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.product = _data["Product"]
        ? ProductApiModel.fromJS(_data["Product"])
        : <any>undefined;
      this.quantity = _data["quantity"];
      this.price = _data["price"];
    }
  }

  static fromJS(data: any): OrderDetail {
    data = typeof data === "object" ? data : {};
    let result = new OrderDetail();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
    data["quantity"] = this.quantity;
    data["price"] = this.price;
    return data;
  }
}

export interface IOrderDetail {
  id?: string | undefined;
  product?: ProductApiModel | undefined;
  quantity: number;
  price?: string | undefined;
}

export class ProductApiModel implements IProductApiModel {
  productId?: string | undefined;
  name?: string | undefined;
  mainImage?: string | undefined;
  deleteAt?: moment.Moment | undefined;
  image?: MemoryStream | undefined;

  constructor(data?: IProductApiModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data["ProductId"];
      this.name = _data["Name"];
      this.mainImage = _data["mainImage"];
      this.deleteAt = _data["deleteAt"]
        ? moment(_data["deleteAt"].toString())
        : <any>undefined;
      this.image = _data["image"]
        ? MemoryStream.fromJS(_data["image"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ProductApiModel {
    data = typeof data === "object" ? data : {};
    let result = new ProductApiModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["ProductId"] = this.productId;
    data["Name"] = this.name;
    data["mainImage"] = this.mainImage;
    data["deleteAt"] = this.deleteAt
      ? this.deleteAt.toISOString()
      : <any>undefined;
    data["image"] = this.image ? this.image.toJSON() : <any>undefined;
    return data;
  }
}

export interface IProductApiModel {
  productId?: string | undefined;
  name?: string | undefined;
  mainImage?: string | undefined;
  deleteAt?: moment.Moment | undefined;
  image?: MemoryStream | undefined;
}

export class ResponseOfUpdateOrderContractResponse
  implements IResponseOfUpdateOrderContractResponse {
  data?: UpdateOrderContractResponse | undefined;
  _links?: LinkBase | undefined;

  constructor(data?: IResponseOfUpdateOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data["data"]
        ? UpdateOrderContractResponse.fromJS(_data["data"])
        : <any>undefined;
      this._links = _data["_links"]
        ? LinkBase.fromJS(_data["_links"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ResponseOfUpdateOrderContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new ResponseOfUpdateOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["data"] = this.data ? this.data.toJSON() : <any>undefined;
    data["_links"] = this._links ? this._links.toJSON() : <any>undefined;
    return data;
  }
}

export interface IResponseOfUpdateOrderContractResponse {
  data?: UpdateOrderContractResponse | undefined;
  _links?: LinkBase | undefined;
}

export class UpdateOrderContractResponse
  implements IUpdateOrderContractResponse {
  orderId?: string | undefined;

  constructor(data?: IUpdateOrderContractResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data["orderId"];
    }
  }

  static fromJS(data: any): UpdateOrderContractResponse {
    data = typeof data === "object" ? data : {};
    let result = new UpdateOrderContractResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["orderId"] = this.orderId;
    return data;
  }
}

export interface IUpdateOrderContractResponse {
  orderId?: string | undefined;
}

export enum OrderStatus {
  Recieved = 1,
  Pending = 2,
  Accepted = 3,
  Canceled = 4,
  WaitingForDriver = 5,
  DriverAccepted = 6,
  DriverRejected = 7,
  OnTheWay = 8,
  Done = 9,
  ReadyOrder = 10,
}

export class CreatePortionRequest implements ICreatePortionRequest {
  id!: number;
  name?: string | undefined;
  isEnabled!: boolean;

  constructor(data?: ICreatePortionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.isEnabled = _data["isEnabled"];
    }
  }

  static fromJS(data: any): CreatePortionRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreatePortionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["isEnabled"] = this.isEnabled;
    return data;
  }
}

export interface ICreatePortionRequest {
  id: number;
  name?: string | undefined;
  isEnabled: boolean;
}

export class UpdatePortionSizeRequest implements IUpdatePortionSizeRequest {
  id!: number;
  name?: string | undefined;
  categoryId?: string | undefined;

  constructor(data?: IUpdatePortionSizeRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.categoryId = _data["categoryId"];
    }
  }

  static fromJS(data: any): UpdatePortionSizeRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePortionSizeRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["categoryId"] = this.categoryId;
    return data;
  }
}

export interface IUpdatePortionSizeRequest {
  id: number;
  name?: string | undefined;
  categoryId?: string | undefined;
}

export class DeletePortionRequest implements IDeletePortionRequest {
  id!: number;
  name?: string | undefined;
  isEnabled!: boolean;

  constructor(data?: IDeletePortionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.isEnabled = _data["isEnabled"];
    }
  }

  static fromJS(data: any): DeletePortionRequest {
    data = typeof data === "object" ? data : {};
    let result = new DeletePortionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["isEnabled"] = this.isEnabled;
    return data;
  }
}

export interface IDeletePortionRequest {
  id: number;
  name?: string | undefined;
  isEnabled: boolean;
}

export class AuthSuccessResponse implements IAuthSuccessResponse {
  token?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: IAuthSuccessResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data["token"];
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): AuthSuccessResponse {
    data = typeof data === "object" ? data : {};
    let result = new AuthSuccessResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["token"] = this.token;
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export interface IAuthSuccessResponse {
  token?: string | undefined;
  refreshToken?: string | undefined;
}

export class AuthFailedResponse implements IAuthFailedResponse {
  errors?: string[] | undefined;

  constructor(data?: IAuthFailedResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["errors"])) {
        this.errors = [] as any;
        for (let item of _data["errors"]) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): AuthFailedResponse {
    data = typeof data === "object" ? data : {};
    let result = new AuthFailedResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.errors)) {
      data["errors"] = [];
      for (let item of this.errors) data["errors"].push(item);
    }
    return data;
  }
}

export interface IAuthFailedResponse {
  errors?: string[] | undefined;
}

export class UserRegistrationRequest implements IUserRegistrationRequest {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: IUserRegistrationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): UserRegistrationRequest {
    data = typeof data === "object" ? data : {};
    let result = new UserRegistrationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    data["password"] = this.password;
    return data;
  }
}

export interface IUserRegistrationRequest {
  email?: string | undefined;
  password?: string | undefined;
}

export class UserLoginRequest implements IUserLoginRequest {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: IUserLoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data["email"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): UserLoginRequest {
    data = typeof data === "object" ? data : {};
    let result = new UserLoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    data["password"] = this.password;
    return data;
  }
}

export interface IUserLoginRequest {
  email?: string | undefined;
  password?: string | undefined;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
  token?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: IRefreshTokenRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.token = _data["token"];
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): RefreshTokenRequest {
    data = typeof data === "object" ? data : {};
    let result = new RefreshTokenRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["token"] = this.token;
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export interface IRefreshTokenRequest {
  token?: string | undefined;
  refreshToken?: string | undefined;
}

export class SwaggerResponse<TResult> {
  status: number;
  headers: { [key: string]: any };
  result: TResult;

  constructor(
    status: number,
    headers: { [key: string]: any },
    result: TResult
  ) {
    this.status = status;
    this.headers = headers;
    this.result = result;
  }
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}

/**
 * Configuration class needed in base class.
 * The config is provided to the API client at initialization time.
 * API clients inherit from #AuthorizedApiBase and provide the config.
 */
/*
 *
 * *
 */

export class IConfig {
  /**
   * Returns a valid value for the Authorization header.
   * Used to dynamically inject the current auth header.
   */
  getAuthorization() {
    //return `Brearer ${TestService.Token()}`;
    return `Bearer ${authToken}`;
  }
  getTenantId() {
    //return `Brearer ${TestService.Token()}`;
    return `${tenantId}`;
  }
  baseUrl() {
    return "https://api.restaurant-qa-two.emp-host.com";
  }
}
